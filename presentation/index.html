<!DOCTYPE html>

<!--
    Google HTML5 slide template

    Authors: Luke Mahé (code)
             Marcin Wichary (code and design)
           
             Dominic Mazzoni (browser compatibility)
             Charles Chen (ChromeVox support)

    URL: http://code.google.com/p/html5slides/
-->

<html>
  <head>
    <title>Scala For Full Stack Development: An Experience Report</title>
    <meta charset='utf-8'>
    <script src='javascript/slides.js'></script>
    <link rel="stylesheet" type="text/css" href="stylesheets/overrides.css"/>
  </head>
  <body style='display: none'>

    <section class='slides layout-regular template-2013naad'>
      
      <article class='front-page'>
        <h1>Scala For Full Stack Development: <br/>An Experience Report</h1>
        <p>Amanda Snyder and Toby Clemson</p>
      </article>

      <article>
        <h3>Here's how we hope it's going to go</h3>
        <ul>
          <li>Introductions</li>
          <ul>
            <li>Who are we?</li>
            <li>What are we using Scala for?</li>
          </ul>
          <li>The language</li>
          <ul style='display: none;'>
            <li>Classes</li>
            <li>Case Classes</li>
            <li>Pattern Matching</li>
            <li>Collection Manipulation</li>
            <li>Option/Either</li>
            <li>Future</li>
            <li>Enumerations</li>
            <li>Type Inference</li>
            <li>Real Life Examples</li>
          </ul>
          <li>The tooling and techniques</li>
          <ul style='display: none;'>
            <li>Compilation</li>
            <li>Build</li>
            <li>Testing</li>
            <li>IDE</li>
            <li>Frameworks</li>
            <li>Dependency Injection</li>
            <li>Code Quality Tools</li>
          </ul>
          <li>The community</li>
          <li>Conclusions</li>
        </ul>
      </article>

      <article>
        <h2>Introductions</h2>
      </article>

      <article>
        <h3>Introductions: Who are we?</h3>
        <ul class='build'>
          <li>Have both been on the first full stack Scala project in the US for the last 3-4 months</li>
          <li>Learnt Scala as we went along with no specific experience prior to the project</li>
          <li>Have had varied levels of exposure to functional programming</li>
        </ul>
        <p class='presenter-notes'>
          Talk a little about the client, what they are doing, what we are doing for them.
        </p>
      </article>

      <article>
        <h3>
          Introductions: What are we using Scala for?
        </h3>
        <img class='greedy-slide-image' src='images/big-picture.png'
             alt='Diagram showing the architecture in which we are using Scala'/>
        <p class='presenter-notes'>
          Describe the technology stack, lots of integration points, using micro-services
          Using Play and DropWizard, relatively simple domain, mostly coordination
        </p>
      </article>

      <article>
        <h2>The Language</h2>
      </article>

      <article>
        <h3>The Language: Type Inference</h3>
        <ul>
          <li>example of generic type and inference</li>
          <li>example of where type inference goes wrong, var thing = None, thing = Option("something")
          <li>beware methods need = to have return type</li>
        </ul>
      </article>

      <article class='smaller'>
        <h3>The Language: Classes</h3>
        <div class='left-comparison-50'>
          <h5>Scala</h5>
          <pre>
class Person(
  var name: String,
  var gender: Gender,
  var age: Integer
)
          </pre>
        </div>
        <div class='right-comparison-50'>
          <h5>Java</h5>
          <pre>
public class Person {
  private String name;
  private Gender gender ;
  private Integer age;
  
  public String getName() {
    return name;
  }
  
  public void setName(String name) {
    this.name = name;
  }

  public Gender getGender() {
    return gender;
  }

  public void setGender(Gender gender) {
    this.gender = gender;
  }

  public Integer getAge() {
    return age;
  }

  public void setAge(Integer age) {
    this.age = age;
  }
}
          </pre>
        </div>
        <p class='presenter-notes'>
          Much less code
          'var' implies mutable objects, with auto generated getters and setters
        </p>
      </article>

      <article class='smaller'>
        <h3>The Language: Case Classes</h3>
        <div class='left-comparison-40'>
          <h5>Scala</h5>
          <pre>
case class Person(
  firstName: String, 
  private middleInitial: String, 
  val lastName: String
)</pre>
        </div>
        <div class='right-comparison-60'>
          <h5>Java</h5>
          <pre class='tiny'>
public class Person 
  extends java.lang.Object 
  implements scala.Product, 
             scala.Serializable {
  
  private final java.lang.String firstName;
  private final java.lang.String middleInitial;
  private final java.lang.String lastName;
  public static scala.Function1 tupled();
  public static scala.Function1 curried();
  private java.lang.String middleInitial();
  public java.lang.String middleInitial$1();
  public java.lang.String firstName();
  public java.lang.String lastName();
  public Person copy(
    java.lang.String, 
    java.lang.String, 
    java.lang.String);
  public java.lang.String copy$default$1();
  public java.lang.String copy$default$2();
  public java.lang.String copy$default$3();
  public java.lang.String productPrefix();
  public int productArity();
  public java.lang.Object productElement(int);
  public scala.collection.Iterator productIterator();
  public boolean canEqual(java.lang.Object);
  public int hashCode();
  public java.lang.String toString();
  public boolean equals(java.lang.Object);
  public Person(
    java.lang.String, 
    java.lang.String, 
    java.lang.String);
}</pre>
        </div>
        <p class='presenter-notes'>
          Immutable by default
          Value type semantics, equals, hash code and to string do the right thing
          Readers for all non private fields
          Copy constructors using named parameters and defaults from constructor
          Pattern matchable
        </p>
      </article>

      <article>
        <h3>The Language: Pattern Matching</h3>
          <pre>
abstract class Outcome
case class Success(retrievedObject: MyObject) extends Outcome
case class Error() extends Outcome


def retrieveObject: Outcome = {…}

def main = {
  retrieveObject match { outcome => 
    case Success(object) => println(s“I found it: ${object}!”)
    case Error() => println(“I couldn’t find it :(”)
    case _ => println(“I don’t know what happened...”)
  }
}</pre>
        <p class='presenter-notes'>
          Allows you to match the different possible return values from a method to how you want to deal with those return values
          Used alongside case classes, you get readable mappings of type to action to be performed
          Matches can have arguments so that values can be extracted from them for use in the corresponding action
          Reduces the need for null checking or exception handling
          The final case is a wildcard matching anything not yet matched
        </p>
      </article>

      <article>
        <h3>The Language: Collection Manipulation</h3>
        <ul>
          <li>map, flatMap</li>
          <li>reduce, mkString</li>
          <li>filter</li>
          <li>foreach</li>
        </ul>
      </article>

      <article>
        <h3>The Language: Option/Either</h3>
        <ul>
          <li>using option to avoid ifs and nulls, map, flatMap, getOrElse</li>
          <li>using either for possible failure or success, good to use with pattern matching</li>
        </ul>
      </article>

      <article>
        <h3>The Language: Futures</h3>
        <ul>
          <li>map, flatMap, recover</li>
        </ul>
      </article>

      <article class='smaller'>
        <h3>The Language: Enumerations</h3>
        <div class='build'>
          <div>
            <h5>Java Enumeration</h5>
            <pre>
public enum DaysOfWeek {
  MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY;

  public static final EnumSet<Weekday> WEEKENDS = EnumSet.range(SATURDAY, SUNDAY);
  public final boolean isWeekend() { return WEEKENDS.contains(this);}
}</pre>
          </div>
          <div>
            <h5>Scala true Enumeration</h5>
            <pre>
object Weekday extends Enumeration {
	type Weekday = Value
	val Mon, Tue, Wed, Thu, Fri, Sat, Sun = Value
}</pre>
          </div>
          <div>
	    <div class='left-comparison-50'>
	      <h5>Scala Enumeration Pattern</h5>
              <pre>
sealed abstract class Weekday{
	def isWeekend: Boolean
}
case class Sunday() extends Weekday {
	def isWeekend = true
}
case class Monday() extends Weekday {
	def isWeekend = false
}
...</pre>
            </div>
            <div class='right-comparison-50'>
	      <h5>Pattern Matching Made Easy</h5>
	      <pre>
def whatShouldIDo(weekday:Weekday) = {
  weekday match { 
    case Monday() =>
      println("Go Play!")
  } 
}

// warning: match may not be exhaustive.
// It would fail on the following input: 
//     Sunday()</pre>
            </div>
          </div>
        </div>
      </article>

      <article>
        <h3>The Language: Example 1</h3>
        <ul>
          <li>Encryption Key</li>
          <ul>
            <li>collection manipulation</li>
            <li>case class</li>
            <li>companion object</li>
            <li>use of apply</li>
            <li>underscore wildcard</li>
          </ul>
        </ul>
      </article>

      <article class='smaller'>
        <h3 style='margin-bottom:10px'>The Language: Example 2</h3>
		<div class='left-comparison-60'>
          <pre >
case class StubResponseBuilder(
  private val headers: Seq[StubHeader] = Seq.empty) {
  def buildJsonString = s"""
    |{
    |  "statusCode" : "200",
    |  "body" : "null",
    |  "headers" : [
    |    ${headers.map(StubHeaderBuilder().from(_).buildJsonString).mkString(",")}
    |  ]
    |}
    """.stripMargin
}

case class StubHeaderBuilder (
  private val key: String = "",
  private val value: String = "") {
    def from(header: StubHeader) = copy(key = header.key, value = header.value)
	
    def buildObject = StubHeader(key, value)
    def buildJsonString = s"""
      |{
      |	"key" : "$key",
      |	"value" : "$value"
      |}
      """.stripMargin
    }
}
</pre>
</div>
<div class='right-comparison-40'>
          <ul>
            <li>copy</li>
            <li>string interpolation and multiline string</li>
            <li>mkString</li>
            <li>default arguments</li>
          </ul>
</div>
      </article>


      <article>
        <h2>The Tooling and Techniques</h2>
      </article>

      <article>
        <h3>The Tooling and Techniques: Compilation</h3>
        <ul>
          <li>Very slow! All those features come at a cost.</li>
          <li>Developer workstations need to be very powerful</li>
          <li>We've resorted to using RAMDISKs to run our build in a reasonable time</li>
          <li>16GB memory, 2.5 GHz, 2 cores</li>
          <li>Build with clean: 1720 seconds = 28.66 minutes</li>
          <li>Build without clean: </li>
        </ul>
      </article>

      <article>
        <h3>The Tooling and Techniques: Build</h3>
        <ul>
          <li>SBT is the build tool of choice</li>
          <li>Considered Gradle which has full Scala support, however no real Play support</li>
          <li>Has a steep learning curve, once basic principles have been understood, is quite powerful although don't run away with it.</li>
          <li>Build scripts are just Scala</li>
          <li>Good support for multi module projects, easy to define cross module dependencies</li>
          <li>IDE configuration generated from project definition, relatively reliable</li>
        </ul>
      </article>

      <article>
        <h3>The Tooling and Techniques: Testing</h3>
        <ul>
          <li>Lots of options: Specs2, ScalaTest, ScalaMock, Mockito</li>
          <li>Had most success with Specs2 and Mockito</li>
          <li>Specs2 model quite difficult to get to grips with, strange type system hackery, before/after/around complicated to use, don't follow convention, tests run in parallel by default.</li>
          <li>Mockito interop has a few wrinkles but on the whole has been successful.</li>
          <li>Also use CucumberJVM for end to end testing, has some Scala support although no IDE support.</li>          
        </ul>
      </article>

      <article>
        <h3>The Tooling and Techniques: IDE</h3>
      </article>

      <article>
        <h3>The Tooling and Techniques: Frameworks</h3>
      </article>

      <article>
        <h3>The Tooling and Techniques: Dependency Injection</h3>
      </article>

      <article>
        <h3>The Tooling and Techniques: Code Quality Tools</h3>
      </article>

      <article>
        <h2>The Community</h2>
      </article>

      <article>
        <h2>Conclusions</h2>
      </article>


    </section>

  </body>
</html>
